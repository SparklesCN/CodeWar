# Stack with getMin();

## [Problem Description]
	实现一个特殊的栈，包括栈的所有基础功能（push, pop, peek）;
	同时还要实现getMin() 功能

## [Problem Requirement]
	1. pop, push, getMin all with time complexity O(1);
	2. You are allowd to use build-in stack structure;

## [Design]
	设计两个Stack, 其中一个Stack用于正常存放数据，另一个Stack则单独存储当前Min值；

	1. 在任何时候，数据都会正常存入stackData;
	2. 每次向stackData push数据之前，将栈顶数据与新数据比较，再次向stackData push更小的那一个数据；

## [Page Num: 1]
```java

public class MyStack {
	private Stack<Integer> stackData;
	private Stack<Integer> stackMin;

	public MyStack() {
		// stackData use to store data;
		this.stackData = new Stack<Integer>;
		// stackMin use to recored Min data;
		this.stackMin = new Stack<Integer>;
	}

	// Push correct element into both stackData and stackMin;
	public void push(int newNum) {
		// push newNum into stackMin strightly while stackMin is Empty;
		if (this.stackMin.isEmpty()) {
			this.stackMin.push(newNum);
		}
		// if newNum smaller than peek element of stackMin, push it on top;
		else if(newNum < this.getMin()) {
			this.stackMin.push(newNum);
		}
		// if newNum bigger than peek element of stackMin, re-push peek element of stackMin into itself;
		else {
			int newMin = this.stackMin.peek();
			this.stackMin.push(newMin);
		}
		// anyway, push data into stackData to record data as norm stack;
		this.stackData.push(newNum);
	}

	// Pop correct element from both stackData and stackMin;
	public int pop() {
		// Throuw error while stack is Empty;
		if (this.stackData.isEmpty()) {
			throw new RuntimeException("Your stack is empty.");
		}
		// pop top element first before pop and reture element from stackData;
		this.stackMin.pop();
		// pop and return top element from stackData;
		return this.stackData.pop();
	}

	// return current Min element in the stack;
	public int getMin() {
		if (this.stackMin.isEmpty()) {
			throw new RuntimeException("Your stack is empty");
		}
		return this.stackMin.peek();
	}
}

```