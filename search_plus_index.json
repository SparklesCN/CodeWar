{"./":{"url":"./","title":"Introduction","keywords":"","body":"代码之争 The CodeWar https://sparklescn.github.io/CodeWar/ Auto GitBook Publish Script Using, check master branch for commit comments; Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/":{"url":"interview_guide/","title":"Interview Guide","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/":{"url":"interview_guide/chapter_1/","title":"章节一：Stack & Queue","keywords":"","body":"本章节含括基本的 栈 与 队列 的问题； Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/1_1.html":{"url":"interview_guide/chapter_1/1_1.html","title":"1. Stack with getMin","keywords":"","body":"Stack with getMin(); [Page Num: 1] [Problem Description] 实现一个特殊的栈，包括栈的所有基础功能（push, pop, peek）; 同时还要实现getMin() 功能 [Difficulty: 1/4] [Problem Requirement] 1. pop, push, getMin all with time complexity O(1); 2. You are allowd to use build-in stack structure; [Design] 设计两个Stack, 其中一个Stack用于正常存放数据，另一个Stack则单独存储当前Min值； 1. 在任何时候，数据都会正常存入stackData; 2. 每次向stackData push数据之前，将栈顶数据与新数据比较，再次向stackData push更小的那一个数据； [CodeWar] import java.io.*; import java.util.*; public class MyStack { private Stack stackData(); private Stack stackMin(); public MyStack() { // stackData use to store data; this.stackData = new Stack; // stackMin use to recored Min data; this.stackMin = new Stack; } // Push correct element into both stackData and stackMin; public void push(int newNum) { // push newNum into stackMin strightly while stackMin is Empty; if (this.stackMin.isEmpty()) { this.stackMin.push(newNum); } // if newNum smaller than peek element of stackMin, push it on top; else if(newNum [Testing] public static void main(String[] args) { MyStack minStack = new MyStack(); minStack.push(5); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 5\"); minStack.push(4); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 4\"); minStack.push(1); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(3); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(2); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); } /* current Min: 5 shoule be: 5 current Min: 4 shoule be: 4 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/1_2.html":{"url":"interview_guide/chapter_1/1_2.html","title":"2. Two Stacks Queue","keywords":"","body":"Two Stacks Queue [Page Num: 5] [Problem Description] 用两个Stack栈来构造一个可以使用的Queue队列结构； 满足先进先出的规则； [Difficulty: 2/4] [Problem Requirnment] 1. Time Complexity shoud be O(1); 2. All function should be functionally works; 3. Only two stacks allowed to use; [Design] Stack栈的特征是first in last out即先进后出； Queue队列的特征是first in first out即先进先出; 就此特征，我们可以在向栈_1放入新的数据之前， 将所有原始数据按照栈的顺序依次pop到栈_2中， 然后再将新数据push进栈_1底部， 最后再依次将栈_2中数据pop回栈_1中； 这样我们就在栈_1中模拟了队列的情况； [CodeWar] import java.io.*; import java.util.*; public class TwoStacksQueue { public Stack stack_1; public Stack stack_2; public TwoStacksQueue() { this.stack_1 = new Stack(); this.stack_2 = new Stack(); } // basic add method for TwoStacksQueue; public void add(int newNum) { // move all elements from stack_1 to stack_2; while (!this.stack_1.isEmpty()) { this.stack_2.push(this.stack_1.pop()); } // push newNum into the empty stack_1; this.stack_1.push(newNum); // move all elements from stack_2 back to stack_1; while (!this.stack_2.isEmpty()) { this.stack_1.push(this.stack_2.pop()); } } // basic pull method for TwoStacksQueue; public int pull() { // normally pop element out from stack_1 and return it; return this.stack_1.pop(); } // basic return the top element in TwoStacksQueue; public int peek() { return this.stack_1.peek(); } } [Testing] public static void main(String[] args) { // test queue; TwoStacksQueue queue = new TwoStacksQueue(); queue.add(1); queue.add(2); queue.add(3); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 2\"); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 3\"); } /* output is: 1 should be: 1 output is: 1 should be: 1 output is: 2 should be: 2 output is: 3 should be: 3 */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/1_3.html":{"url":"interview_guide/chapter_1/1_3.html","title":"3. Recursively Reverse Stack","keywords":"","body":"Reverse a Stack [Page Num: 7] [Problem Description] Recursively reverse a stack; [Difficulty: 2/4] [Problem Requirnment] The only Stack you are allowed to use is which one you need to reverse; Recursively; [Design] Since we are not allow to use second Stack for help, we have to use temp memory to record the temp data each time; In other words, we need to use recursive to solve this problem; We gonna need two methods; 1. A method which could return and remove last element in a stack; Generally, the first recursive method should be two parts; First, remove and return last element in a stack; Second, make sure the stack looks same as before unless the last element been removed; 2. A method use to reverse a stack by useing method 1; In this method, we have to use temp memory to store our temp data since we don't have extra stack to store data; The norm way to do this is that use method to get last element of a stack, and recursively get the last element of the new stack until it's empty; Then put all \"last element\" back to the stack in ordered; [CodeWar] import java.io.*; import java.util.*; public class ReverseStack { public static int getAndRemoveLastElement(Stack stack) { int result = stack.pop(); if (stack.isEmpty()) { return result; } else { int lastElement = getAndRemoveLastElement(stack); stack.push(result); return lastElement; } } public static void reverseStack(Stack stack) { if (stack.isEmpty()) { return; } else { int temp = getAndRemoveLastElement(stack); reverseStack(stack); stack.push(temp); } } } [Testing] public static void main(String[] args) { Stack stack = new Stack(); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for getAndRemoveLastElement getAndRemoveLastElement(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for reverseStack reverseStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for push stack.push(1); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } /* Current Stack Bottom->Top [1, 2, 3, 4, 5] Current Stack Bottom->Top [2, 3, 4, 5] Current Stack Bottom->Top [5, 4, 3, 2] Current Stack Bottom->Top [5, 4, 3, 2, 1] */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/1_4.html":{"url":"interview_guide/chapter_1/1_4.html","title":"4. Cat & Dog Problem - TODO","keywords":"","body":"Auto test public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"1_4\"); } } Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_1/1_5.html":{"url":"interview_guide/chapter_1/1_5.html","title":"5. Sort Stack by Stack","keywords":"","body":"Sort Stack by another Stack [Page Num: 12] [Problem Description] 给定一个乱序Stack，要求在仅借助另外一个辅助Stack来完成对原始Stack的排序； 排序要求：Top -> Bottom High -> Low [Difficulty: 1/4] [Problem Requirnment] 仅可借助另外1个辅助Stack； [Design] ref: textbook pg:12 1. 将要排序的栈记为stack，另一个辅助栈记为help。 在stack执行pop操作，弹出top值并记录返回出的top值为temp; 2. 如果cur小于或等于help的栈顶元素，则将cur正常压入help； 3. 否则，则按顺序将help中所有元素弹出，并压入stack。 当help栈空之后，将存下的temp压入help底部； 重复执行操作1； [CodeWar] import java.io.*; import java.util.*; public class SortStack { // use another temp stack to sort input stack public static void sortStack(Stack stack) { // declare the help stack; Stack help = new Stack(); // loop until input stack was empty, which means sort completed; while(!stack.isEmpty()) { int temp = stack.pop(); while (!help.isEmpty() && help.peek() [Testing] public static void main(String[] args) { Stack stack = new Stack(); stack.push(3); stack.push(1); stack.push(2); stack.push(5); stack.push(4); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); sortStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } /* public static void main(String[] args) { Stack stack = new Stack(); stack.push(3); stack.push(1); stack.push(2); stack.push(5); stack.push(4); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); sortStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_2/":{"url":"interview_guide/chapter_2/","title":"章节二：Linked List","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_2/2_1.html":{"url":"interview_guide/chapter_2/2_1.html","title":"1. Print Common Part of Two Orderd Linked Lists","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"interview_guide/chapter_2/2_2.html":{"url":"interview_guide/chapter_2/2_2.html","title":"2. Delete the Node in k to last of Linked List and Double Linked List","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/":{"url":"leetcode/","title":"LeetCode","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/easy/":{"url":"leetcode/easy/","title":"Difficulty: EASY","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/easy/1/1.html":{"url":"leetcode/easy/1/1.html","title":"1. Two Sum","keywords":"","body":"[1] Two Sum [Page Address] https://leetcode.com/problems/two-sum/description/ algorithms Easy (44.38%) Total Accepted: 2M Total Submissions: 4.5M [Problem Description] Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. [Difficulty: EASY] [Design] 1. 复制出一个新的inputArray; 2. 对新的inputArray进行排序； 左小右大； 3. 设置两个指针，分别在左端点和右端点，即最小点和最大点； 4. 两指针对应值相加，判断sum值和target关系； 5-1. 如果sum target 则意味sum值需要减小，所以将右指针向左移动一位； 5-3. 如果sum == target 则意味已找到匹配组；将index记录下，跳出循环； [CodeWar] class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; int[] copyNums = new int[nums.length]; for (int i = 0; i target) { rightIndex--; } else { break; } } for (int i = 0; i = 0; i--) { if (nums[i] == copyNums[rightIndex]) { result[1] = i; break; } } return result; } } [Testing] Input data: [2,7,11,15] 9 Actual ✔ runtime: 0 ms ✔ answer: [0,1] ✔ stdout: '' Expected ✔ runtime: 4 ms ✔ answer: [0,1] ✔ stdout: '' [Submission] ✔ Accepted ✔ 29/29 cases passed (2 ms) ✔ Your runtime beats 93.56 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-07 09:47:35 "},"leetcode/medium/":{"url":"leetcode/medium/","title":"Difficulty: MEDIUM","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/medium/2.html":{"url":"leetcode/medium/2.html","title":"2. Add Two Numbers","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/hard/":{"url":"leetcode/hard/","title":"Difficulty: HARD","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"leetcode/hard/4.html":{"url":"leetcode/hard/4.html","title":"4. Median of Two Sorted Arrays","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/":{"url":"collections/","title":"Collections","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/":{"url":"collections/huawei/","title":"华为","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/0/":{"url":"collections/huawei/0/","title":"剔除字符串中重复字符","keywords":"","body":"Remove Repeat Chars in String [Source: HUA WEI] [Problem Description] 给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。 [Difficulty: EASY] [Problem Requirnment] 输入数据是一个字符串（不包含空格） 输出去重后的字符串 输入：12ere2 输出：12er [Design] 1. 将字符串转为字符列表； 2. 用HashMap存下每个字符第一次出现的Index； 3. 遍历整个字符串列表，仅保留符合HashMap记录数据的字符； [CodeWar] import java.io.*; import java.util.*; public class removeRepeats { public static String removeRepeat (String input) { char[] inputArray = input.toCharArray(); Map map = new HashMap(); int counter = 0; for (int i = 0; i [Testing] public static void main(String[] args) { String test_1 = \"abacbd\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_1)); System.out.println(\"should be: abcd\"); String test_2 = \"abc\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_2)); System.out.println(\"should be: abc\"); String test_3 = \"aaa\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_3)); System.out.println(\"should be: a\"); String test_4 = \"aabbccdd\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_4)); System.out.println(\"should be: abcd\"); String test_5 = \"12ere2\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_5)); System.out.println(\"should be: 12er\"); /* output is: abcd should be: abcd output is: abc should be: abc output is: a should be: a output is: abcd should be: abcd output is: 12er should be: 12er */ } Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/1/":{"url":"collections/huawei/1/","title":"字符串最后一个单词的长度","keywords":"","body":"Count the length of last word [Source: HUA WEI] [Problem Description] 计算字符串最后一个单词的长度，单词以空格隔开。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 [Design] 1. 运用split方法将包含多单词的字符串分割为String Array； 2. 直接获取最后一位的字符串长度； [Note] str.split()方法: str = \"hello world\"; str.split -> return type: String[] {hello, world} [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String[] inputArray = scanner.nextLine().split(\" \"); System.out.println(inputArray[inputArray.length-1].length()); } } } [Testing] 输入 hello world 输出 5 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/2/":{"url":"collections/huawei/2/","title":"计算目标字符个数","keywords":"","body":"计算目标字符个数 [Source: HUA WEI] [Problem Description] 写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。 输出描述: 输出输入字符串中含有该字符的个数。 [Design] 1. 由于本题不区分字母大小写，在把整个字符串直接转化为统一小写字母的charArray； 2. 将目标字符也按照统一标准转化为小写字母； 3. 遍历整个charArray进行比较并计数； [Note] 1. Character.toLowerCase(String str) -> 会将字符串中所有大写字母转小写，其余不变, 返回新字符串； 2. Character.toLowerCase(char c) -> 如果该字符是大写字母，将会被转为小写字母，否则保持不变，返回新字符； 3. str.toCharArray() -> 将str按照每个字符，按顺序分割为charArray，返回新charArray; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner input = new Scanner(System.in); char[] inputArray; char target; int counter = 0; while (input.hasNext()) { inputArray = input.nextLine().toLowerCase().toCharArray(); target = Character.toLowerCase(input.next().charAt(0)); for (char c:inputArray) { if (target == c) { counter++; } } System.out.println(counter); counter = 0; } } } [Testing] 输入 ABCDEF A 输出 1 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/3/":{"url":"collections/huawei/3/","title":"随机数去重和排序","keywords":"","body":"随机数去重和排序 [Source: HUA WEI] [Problem Description] 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 [Design] 1. 获取总随机数个数，得到循坏次数； 2. 用HashSet存储所有随机数并完成去重工作； 3. 将hashSet转换为array，然后对array进行排序； [Note] 1. 建立一个HashSet: Set hashSet = new HashSet(); 2. 将hashSet转换为array: hashSet.toArray() -> 将hashSet变为对应类型array，返回新array； 3. 排序一个array Arrays.sort(Object[] array) -> 直接排序输入array，直接覆盖原array, 不返回值； 4. array转换为string Arrays.toString(Object[] array) -> 将array转换为string，返回新string； 5. char转换为string Character.toString(char c) -> 将char转换为string，返回新string； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner input = new Scanner(System.in); while(input.hasNext()) { int length = input.nextInt(); Set set = new HashSet(); for (int i = 0; i [Testing] 输入 11 10 20 40 32 67 40 20 89 300 400 15 输出 10 15 20 32 40 67 89 300 400 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"collections/huawei/4/":{"url":"collections/huawei/4/","title":"字符串分割","keywords":"","body":"字符串分割 [Source: HUA WEI] [Problem Description] •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 连续输入字符串(输入2次,每个字符串长度小于100) 输出描述: 输出到长度为8的新字符串数组 [Design] 1. 计算是否字符串可以被8整除，即判断最后一个被分割下来的字符串需不需要补'0'； 2. 如果需要补'0'，计算需要补的个数，然后直接添加到未分割的字符串末尾； 3. 以8为间隔分割字符串； [Note] 1. 分割字符串方法： str.substring(a) -> 截取从index a 到 末尾的整个字符串，包含a，返回新字符串； str.substring(a, b) -> 截取从index a 到 index b的整个字符串，包含a不包含b，返回新字符串； 2. scanner.nextInt() 不会跳转到下一行，记得手动用 scanner.nextLine()跳转； 3. scanner.next() 会自动跳转到下一行； 4. 读取下一个字符： scanner.next().charAt(0); 5. 补充：scanner.next() 和 scanner.nextLine()的区别： input stream = \"hello world\" // 用scanner.next()连续System.out.print需要打印两次 -> helloworld // 用scanner.nextLine()System.out.print只用打印一次 -> hello world 简单来说，基本运行效果相同，但是next不会读取后面的空格；next遇到空格会停止，但是nextLine会读取整行内容直到遇到换行符； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void printSubstrings(String str) { int leftNums = str.length()%8; int fixLoopTimes = 0; if (leftNums != 0) { fixLoopTimes = 8 - leftNums; } for (int i = 0; i [Testing] 输入 abc 123456789 输出 abc00000 12345678 90000000 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-12 09:08:26 "},"collections/huawei/5/":{"url":"collections/huawei/5/","title":"进制转换","keywords":"","body":"进制转换 [Source: HUA WEI] [Problem Description] 写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 [Design] 1. 利用str.substring拆离出有效计数位； 2. 使用Integer.parseInt()转换有效计数位； [Note] 关于利用java内置库将非十进制数字转化到十进制： 举例：转化 \"0xA\" -> 10 Integer.parseInt(\"A\", 16); -> 10 java official docs: https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String,%20int) [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String input = scanner.nextLine().substring(2); int result = Integer.parseInt(input, 16); System.out.println(result); } } } [Testing] 输入 0xA 输出 10 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-12 09:08:26 "},"collections/huawei/6/":{"url":"collections/huawei/6/","title":"质数因子","keywords":"","body":"质数因子 [Source: HUA WEI] [Problem Description] 功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ） 最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String [Difficulty: MEDIUM] [Problem Requirnment] 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 [Design] 利用分解质因数规则： https://www.shuxuele.com/prime-factorization.html [Note] 如何将char转换为String: 1. String str = 'c' + \"\"; 2. String str = Character.toString('c'); [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printPrims(scanner.nextLong()); } } public static void printPrims(long num) { if (num == 0) { System.out.println(\"0 \"); return; } String res = \"\"; int curPrim = 2; while (num != 1) { while (num % curPrim == 0) { res = res + curPrim + \" \"; num = num / curPrim; } curPrim++; } System.out.println(res); } } [Testing] 输入 180 输出 2 2 3 3 5 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-12 09:08:26 "},"knowledge/":{"url":"knowledge/","title":"Basic Knowledge","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/dataStructures/":{"url":"knowledge/dataStructures/","title":"Data Structures","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/algorithems/":{"url":"knowledge/algorithems/","title":"Algorithems","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/":{"url":"knowledge/languages/","title":"Languages","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/java/":{"url":"knowledge/languages/java/","title":"Java","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/python/":{"url":"knowledge/languages/python/","title":"Python","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/javaScript/":{"url":"knowledge/languages/javaScript/","title":"JavaScript","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/c/":{"url":"knowledge/languages/c/","title":"C","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/cpp/":{"url":"knowledge/languages/cpp/","title":"C++","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/swift/":{"url":"knowledge/languages/swift/","title":"Swift","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/languages/html5_css3/":{"url":"knowledge/languages/html5_css3/","title":"HTML5 && CSS3","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/tools/":{"url":"knowledge/tools/","title":"Tools","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/tools/git/":{"url":"knowledge/tools/git/","title":"Git","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/tools/docker/":{"url":"knowledge/tools/docker/","title":"Docker","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/tools/mySql/":{"url":"knowledge/tools/mySql/","title":"MySQL","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/gameDevelopment/":{"url":"knowledge/gameDevelopment/","title":"Game Development","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/gameDevelopment/unity3D/":{"url":"knowledge/gameDevelopment/unity3D/","title":"Unity3D","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "},"knowledge/gameDevelopment/unreal4/":{"url":"knowledge/gameDevelopment/unreal4/","title":"Unreal 4","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-13 21:58:40 "}}