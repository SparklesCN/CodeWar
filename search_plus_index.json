{"./":{"url":"./","title":"Introduction","keywords":"","body":"代码之争 https://sparkles.gitbook.io/codewar/ Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/":{"url":"chapter_1/","title":"Stack & Queue","keywords":"","body":"本章节含括基本的 栈 与 队列 的问题； Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/1_1.html":{"url":"chapter_1/1_1.html","title":"Stack with getMin","keywords":"","body":"Stack with getMin(); [Page Num: 1] [Problem Description] 实现一个特殊的栈，包括栈的所有基础功能（push, pop, peek）; 同时还要实现getMin() 功能 [Difficulty: 1/4] [Problem Requirement] 1. pop, push, getMin all with time complexity O(1); 2. You are allowd to use build-in stack structure; [Design] 设计两个Stack, 其中一个Stack用于正常存放数据，另一个Stack则单独存储当前Min值； 1. 在任何时候，数据都会正常存入stackData; 2. 每次向stackData push数据之前，将栈顶数据与新数据比较，再次向stackData push更小的那一个数据； [CodeWar] import java.io.*; import java.util.*; public class MyStack { private Stack stackData(); private Stack stackMin(); public MyStack() { // stackData use to store data; this.stackData = new Stack; // stackMin use to recored Min data; this.stackMin = new Stack; } // Push correct element into both stackData and stackMin; public void push(int newNum) { // push newNum into stackMin strightly while stackMin is Empty; if (this.stackMin.isEmpty()) { this.stackMin.push(newNum); } // if newNum smaller than peek element of stackMin, push it on top; else if(newNum [Testing] public static void main(String[] args) { MyStack minStack = new MyStack(); minStack.push(5); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 5\"); minStack.push(4); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 4\"); minStack.push(1); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(3); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(2); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); } /* current Min: 5 shoule be: 5 current Min: 4 shoule be: 4 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 */ Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/1_2.html":{"url":"chapter_1/1_2.html","title":"Two Stacks Queue","keywords":"","body":"Two Stacks Queue [Page Num: 5] [Problem Description] 用两个Stack栈来构造一个可以使用的Queue队列结构； 满足先进先出的规则； [Difficulty: 2/4] [Problem Requirnment] 1. Time Complexity shoud be O(1); 2. All function should be functionally works; 3. Only two stacks allowed to use; [Design] Stack栈的特征是first in last out即先进后出； Queue队列的特征是first in first out即先进先出; 就此特征，我们可以在向栈_1放入新的数据之前， 将所有原始数据按照栈的顺序依次pop到栈_2中， 然后再将新数据push进栈_1底部， 最后再依次将栈_2中数据pop回栈_1中； 这样我们就在栈_1中模拟了队列的情况； [CodeWar] import java.io.*; import java.util.*; public class TwoStacksQueue { public Stack stack_1; public Stack stack_2; public TwoStacksQueue() { this.stack_1 = new Stack(); this.stack_2 = new Stack(); } // basic add method for TwoStacksQueue; public void add(int newNum) { // move all elements from stack_1 to stack_2; while (!this.stack_1.isEmpty()) { this.stack_2.push(this.stack_1.pop()); } // push newNum into the empty stack_1; this.stack_1.push(newNum); // move all elements from stack_2 back to stack_1; while (!this.stack_2.isEmpty()) { this.stack_1.push(this.stack_2.pop()); } } // basic pull method for TwoStacksQueue; public int pull() { // normally pop element out from stack_1 and return it; return this.stack_1.pop(); } // basic return the top element in TwoStacksQueue; public int peek() { return this.stack_1.peek(); } } [Testing] public static void main(String[] args) { // test queue; TwoStacksQueue queue = new TwoStacksQueue(); queue.add(1); queue.add(2); queue.add(3); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 2\"); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 3\"); } /* output is: 1 should be: 1 output is: 1 should be: 1 output is: 2 should be: 2 output is: 3 should be: 3 */ Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/1_3.html":{"url":"chapter_1/1_3.html","title":"Recursively Reverse Stack","keywords":"","body":"test!!! public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"1_3\"); } } Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/1_4.html":{"url":"chapter_1/1_4.html","title":"Cat & Dog Problem","keywords":"","body":" public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"1_4\"); } } Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "},"chapter_1/1_5.html":{"url":"chapter_1/1_5.html","title":"Sort Stack by Stack","keywords":"","body":" public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"1_5\"); } } Copyright © sparklscn.com 2019 all right reserved，powered by Gitbook该文件修订时间： 2019-08-03 20:44:17 "}}