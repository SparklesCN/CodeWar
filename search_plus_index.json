{"./":{"url":"./","title":"Introduction","keywords":"","body":"代码之争 The CodeWar https://sparklescn.github.io/CodeWar/ Auto GitBook Publish Script Using, check master branch for commit comments; Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/":{"url":"interview_guide/","title":"Interview Guide","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/":{"url":"interview_guide/chapter_1/","title":"章节一：Stack & Queue","keywords":"","body":"本章节含括基本的 栈 与 队列 的问题； Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/1_1.html":{"url":"interview_guide/chapter_1/1_1.html","title":"1. Stack with getMin","keywords":"","body":"Stack with getMin(); [Page Num: 1] [Problem Description] 实现一个特殊的栈，包括栈的所有基础功能（push, pop, peek）; 同时还要实现getMin() 功能 [Difficulty: 1/4] [Problem Requirement] 1. pop, push, getMin all with time complexity O(1); 2. You are allowd to use build-in stack structure; [Design] 设计两个Stack, 其中一个Stack用于正常存放数据，另一个Stack则单独存储当前Min值； 1. 在任何时候，数据都会正常存入stackData; 2. 每次向stackData push数据之前，将栈顶数据与新数据比较，再次向stackData push更小的那一个数据； [CodeWar] import java.io.*; import java.util.*; public class MyStack { private Stack stackData(); private Stack stackMin(); public MyStack() { // stackData use to store data; this.stackData = new Stack; // stackMin use to recored Min data; this.stackMin = new Stack; } // Push correct element into both stackData and stackMin; public void push(int newNum) { // push newNum into stackMin strightly while stackMin is Empty; if (this.stackMin.isEmpty()) { this.stackMin.push(newNum); } // if newNum smaller than peek element of stackMin, push it on top; else if(newNum [Testing] public static void main(String[] args) { MyStack minStack = new MyStack(); minStack.push(5); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 5\"); minStack.push(4); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 4\"); minStack.push(1); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(3); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); minStack.push(2); System.out.println(\"current Min: \" + minStack.getMin()); System.out.println(\"shoule be: 1\"); } /* current Min: 5 shoule be: 5 current Min: 4 shoule be: 4 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 current Min: 1 shoule be: 1 */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/1_2.html":{"url":"interview_guide/chapter_1/1_2.html","title":"2. Two Stacks Queue","keywords":"","body":"Two Stacks Queue [Page Num: 5] [Problem Description] 用两个Stack栈来构造一个可以使用的Queue队列结构； 满足先进先出的规则； [Difficulty: 2/4] [Problem Requirnment] 1. Time Complexity shoud be O(1); 2. All function should be functionally works; 3. Only two stacks allowed to use; [Design] Stack栈的特征是first in last out即先进后出； Queue队列的特征是first in first out即先进先出; 就此特征，我们可以在向栈_1放入新的数据之前， 将所有原始数据按照栈的顺序依次pop到栈_2中， 然后再将新数据push进栈_1底部， 最后再依次将栈_2中数据pop回栈_1中； 这样我们就在栈_1中模拟了队列的情况； [CodeWar] import java.io.*; import java.util.*; public class TwoStacksQueue { public Stack stack_1; public Stack stack_2; public TwoStacksQueue() { this.stack_1 = new Stack(); this.stack_2 = new Stack(); } // basic add method for TwoStacksQueue; public void add(int newNum) { // move all elements from stack_1 to stack_2; while (!this.stack_1.isEmpty()) { this.stack_2.push(this.stack_1.pop()); } // push newNum into the empty stack_1; this.stack_1.push(newNum); // move all elements from stack_2 back to stack_1; while (!this.stack_2.isEmpty()) { this.stack_1.push(this.stack_2.pop()); } } // basic pull method for TwoStacksQueue; public int pull() { // normally pop element out from stack_1 and return it; return this.stack_1.pop(); } // basic return the top element in TwoStacksQueue; public int peek() { return this.stack_1.peek(); } } [Testing] public static void main(String[] args) { // test queue; TwoStacksQueue queue = new TwoStacksQueue(); queue.add(1); queue.add(2); queue.add(3); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 1\"); System.out.println(\"output is: \" + queue.pull()); System.out.println(\"should be: 2\"); System.out.println(\"output is: \" + queue.peek()); System.out.println(\"should be: 3\"); } /* output is: 1 should be: 1 output is: 1 should be: 1 output is: 2 should be: 2 output is: 3 should be: 3 */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/1_3.html":{"url":"interview_guide/chapter_1/1_3.html","title":"3. Recursively Reverse Stack","keywords":"","body":"Reverse a Stack [Page Num: 7] [Problem Description] Recursively reverse a stack; [Difficulty: 2/4] [Problem Requirnment] The only Stack you are allowed to use is which one you need to reverse; Recursively; [Design] Since we are not allow to use second Stack for help, we have to use temp memory to record the temp data each time; In other words, we need to use recursive to solve this problem; We gonna need two methods; 1. A method which could return and remove last element in a stack; Generally, the first recursive method should be two parts; First, remove and return last element in a stack; Second, make sure the stack looks same as before unless the last element been removed; 2. A method use to reverse a stack by useing method 1; In this method, we have to use temp memory to store our temp data since we don't have extra stack to store data; The norm way to do this is that use method to get last element of a stack, and recursively get the last element of the new stack until it's empty; Then put all \"last element\" back to the stack in ordered; [CodeWar] import java.io.*; import java.util.*; public class ReverseStack { public static int getAndRemoveLastElement(Stack stack) { int result = stack.pop(); if (stack.isEmpty()) { return result; } else { int lastElement = getAndRemoveLastElement(stack); stack.push(result); return lastElement; } } public static void reverseStack(Stack stack) { if (stack.isEmpty()) { return; } else { int temp = getAndRemoveLastElement(stack); reverseStack(stack); stack.push(temp); } } } [Testing] public static void main(String[] args) { Stack stack = new Stack(); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for getAndRemoveLastElement getAndRemoveLastElement(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for reverseStack reverseStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); // test for push stack.push(1); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } /* Current Stack Bottom->Top [1, 2, 3, 4, 5] Current Stack Bottom->Top [2, 3, 4, 5] Current Stack Bottom->Top [5, 4, 3, 2] Current Stack Bottom->Top [5, 4, 3, 2, 1] */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/1_4.html":{"url":"interview_guide/chapter_1/1_4.html","title":"4. Cat & Dog Problem - TODO","keywords":"","body":"Auto test public class Test { public static void main(String[] args) { System.out.println(\"Hello World!\"); System.out.println(\"1_4\"); } } Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_1/1_5.html":{"url":"interview_guide/chapter_1/1_5.html","title":"5. Sort Stack by Stack","keywords":"","body":"Sort Stack by another Stack [Page Num: 12] [Problem Description] 给定一个乱序Stack，要求在仅借助另外一个辅助Stack来完成对原始Stack的排序； 排序要求：Top -> Bottom High -> Low [Difficulty: 1/4] [Problem Requirnment] 仅可借助另外1个辅助Stack； [Design] ref: textbook pg:12 1. 将要排序的栈记为stack，另一个辅助栈记为help。 在stack执行pop操作，弹出top值并记录返回出的top值为temp; 2. 如果cur小于或等于help的栈顶元素，则将cur正常压入help； 3. 否则，则按顺序将help中所有元素弹出，并压入stack。 当help栈空之后，将存下的temp压入help底部； 重复执行操作1； [CodeWar] import java.io.*; import java.util.*; public class SortStack { // use another temp stack to sort input stack public static void sortStack(Stack stack) { // declare the help stack; Stack help = new Stack(); // loop until input stack was empty, which means sort completed; while(!stack.isEmpty()) { int temp = stack.pop(); while (!help.isEmpty() && help.peek() [Testing] public static void main(String[] args) { Stack stack = new Stack(); stack.push(3); stack.push(1); stack.push(2); stack.push(5); stack.push(4); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); sortStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } /* public static void main(String[] args) { Stack stack = new Stack(); stack.push(3); stack.push(1); stack.push(2); stack.push(5); stack.push(4); // original stack String values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); sortStack(stack); values = Arrays.toString(stack.toArray()); System.out.print(\"Current Stack Bottom->Top \"); System.out.println(values); } */ Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_2/":{"url":"interview_guide/chapter_2/","title":"章节二：Linked List","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_2/2_1.html":{"url":"interview_guide/chapter_2/2_1.html","title":"1. Print Common Part of Two Orderd Linked Lists","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"interview_guide/chapter_2/2_2.html":{"url":"interview_guide/chapter_2/2_2.html","title":"2. Delete the Node in k to last of Linked List and Double Linked List","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/":{"url":"leetcode/","title":"LeetCode","keywords":"","body":"[Operation Commands]: // list all easy question leetcode list -q e // 打开并创建题目344 leetcode show 344 -g -x -e // 提交这个文件到leetcode leetcode submit reverse-string.java // 测试例子 leetcode test maximum-subarray.java '[-2,1,-3,4,-1,2,1,-5,4]' Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/easy/":{"url":"leetcode/easy/","title":"Difficulty: EASY","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/easy/1/":{"url":"leetcode/easy/1/","title":"1. Two Sum 两数之和","keywords":"","body":"[1] Two Sum 两数之和 [Page Address] https://leetcode.com/problems/two-sum/description/ algorithms Easy (44.38%) Total Accepted: 2M Total Submissions: 4.5M [Problem Description] Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: Given nums = [2, 7, 11, 15], target = 9, Because nums[0] + nums[1] = 2 + 7 = 9, return [0, 1]. 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1] [Difficulty: EASY] [Design] 1. 复制出一个新的inputArray; 2. 对新的inputArray进行排序； 左小右大； 3. 设置两个指针，分别在左端点和右端点，即最小点和最大点； 4. 两指针对应值相加，判断sum值和target关系； 5-1. 如果sum target 则意味sum值需要减小，所以将右指针向左移动一位； 5-3. 如果sum == target 则意味已找到匹配组；将index记录下，跳出循环； [CodeWar] class Solution { public int[] twoSum(int[] nums, int target) { int[] result = new int[2]; int[] copyNums = new int[nums.length]; for (int i = 0; i target) { rightIndex--; } else { break; } } for (int i = 0; i = 0; i--) { if (nums[i] == copyNums[rightIndex]) { result[1] = i; break; } } return result; } } [Testing] Input data: [2,7,11,15] 9 Actual ✔ runtime: 0 ms ✔ answer: [0,1] ✔ stdout: '' Expected ✔ runtime: 4 ms ✔ answer: [0,1] ✔ stdout: '' [Submission] ✔ Accepted ✔ 29/29 cases passed (2 ms) ✔ Your runtime beats 93.56 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-23 05:25:44 "},"leetcode/easy/7/":{"url":"leetcode/easy/7/","title":"7. Reverse Integer 整数反转","keywords":"","body":"[7] Reverse Integer 整数反转 [Page Address] * https://leetcode.com/problems/reverse-integer/description/ * * algorithms * Easy (25.42%) * Total Accepted: 770K * Total Submissions: 3M [Problem Description] * Given a 32-bit signed integer, reverse digits of an integer. * * Example 1: * * * Input: 123 * Output: 321 * * * Example 2: * * * Input: -123 * Output: -321 * * * Example 3: * * * Input: 120 * Output: 21 * * * Note: * Assume we are dealing with an environment which could only store integers * within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For the purpose * of this problem, assume that your function returns 0 when the reversed * integer overflows. 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 输入: 123 输出: 321 示例 2: 输入: -123 输出: -321 示例 3: 输入: 120 输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231, 231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 [Difficulty: EASY] [Design] 1. 判断和记录数字是否为负； 2. 将数字转换为字符串； 3. 如果是负数，截取’-‘后面的字符串； 4. 翻转字符串； 5. 如果是负数，第一位补充’-‘； [Note] 1. StringBuffer可以实现插入功能； 2. 在把字符串转换为整数过程中，为防止整数大小溢出，需要catch exception; [CodeWar] class Solution { public int reverse(int x) { boolean isNeg = x = 0; i--) { sBuffer.append(str.charAt(i)); } if (isNeg) { sBuffer.insert(0, '-'); } try { return Integer.parseInt(sBuffer.toString()); } catch (Exception e) { return 0; } } } [Testing] Input data: 123 Actual ✔ runtime: 1 ms ✔ answer: 321 ✔ stdout: '' Expected ✔ runtime: 4 ms ✔ answer: 321 ✔ stdout: '' [Submission] ✔ Accepted ✔ 1032/1032 cases passed (2 ms) ✔ Your runtime beats 18.94 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/easy/20/":{"url":"leetcode/easy/20/","title":"20. Valid Parentheses 有效的括号","keywords":"","body":"[20] Valid Parentheses 有效的括号 [Page Address] * https://leetcode.com/problems/valid-parentheses/description/ * * algorithms * Easy (36.97%) * Total Accepted: 668.7K * Total Submissions: 1.8M [Problem Description] * Given a string containing just the characters '(', ')', '{', '}', '[' and * ']', determine if the input string is valid. * * An input string is valid if: * * * Open brackets must be closed by the same type of brackets. * Open brackets must be closed in the correct order. * * * Note that an empty string is also considered valid. * * Example 1: * * * Input: \"()\" * Output: true * * * Example 2: * * * Input: \"()[]{}\" * Output: true * * * Example 3: * * * Input: \"(]\" * Output: false * * * Example 4: * * * Input: \"([)]\" * Output: false * * * Example 5: * * * Input: \"{[]}\" * Output: true 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 注意空字符串可被认为是有效字符串。 示例 1: 输入: \"()\" 输出: true 示例 2: 输入: \"()[]{}\" 输出: true 示例 3: 输入: \"(]\" 输出: false 示例 4: 输入: \"([)]\" 输出: false 示例 5: 输入: \"{[]}\" 输出: true [Difficulty: EASY] [Design] 运用栈的特性，遍历字符串，遇到左半部分时压入右半部分，遇到右半部分时弹出。 1. 如果任意一次弹出和当前字符不同，则不是有效的； 2. 如果遍历还没结束，但是stack变空了，也不是有效的； 3. 整个遍历顺利结束结束，且stack为空，则为有效的，反之则无效； [Note] 1. 注意遍历过程没结束时，如果stack变为空，也是说明是无效匹配； 2. 最后遍历结束，记得再判断一次stack是否为空，此时stack必需为空； [CodeWar] class Solution { public boolean isValid(String s) { Stack stack = new Stack(); for (char c : s.toCharArray()) { if (c == '(') { stack.push(')'); } else if (c == '[') { stack.push(']'); } else if (c == '{') { stack.push('}'); } else { if (stack.isEmpty() || c != stack.pop()) { return false; } } } return stack.isEmpty(); } } [Testing] Input data: \"()\" Actual ✔ runtime: 0 ms ✔ answer: true ✔ stdout: '' Expected ✔ runtime: 4 ms ✔ answer: true ✔ stdout: '' [Submission] ✔ Accepted ✔ 76/76 cases passed (1 ms) ✔ Your runtime beats 93.04 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/easy/53/":{"url":"leetcode/easy/53/","title":"53. Maximum Subarray 最大子序和","keywords":"","body":"[53] Maximum Subarray 最大子序和 [Page Address] * https://leetcode.com/problems/maximum-subarray/description/ * * algorithms * Easy (44.17%) * Total Accepted: 601.5K * Total Submissions: 1.4M [Problem Description] * Given an integer array nums, find the contiguous subarray (containing at * least one number) which has the largest sum and return its sum. * * Example: * * * Input: [-2,1,-3,4,-1,2,1,-5,4], * Output: 6 * Explanation: [4,-1,2,1] has the largest sum = 6. * * * Follow up: * * If you have figured out the O(n) solution, try coding another solution using * the divide and conquer approach, which is more subtle. 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 输入: [-2,1,-3,4,-1,2,1,-5,4], 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 [Difficulty: EASY] [Design] 详情见代码注释； [Note] None; [CodeWar] class Solution { public int maxSubArray(int[] nums) { int max = nums[0]; int sum = 0; for (int num : nums) { // if sum > 0, means still possible get a greater sum; // 如果sum大于零，意味着相加还有可能得到一个更大的sum； if (sum > 0) { sum += num; } // if sum [Testing] Input data: [-2,1,-3,4,-1,2,1,-5,4] Actual ✔ runtime: 0 ms ✔ answer: 6 ✔ stdout: '' Expected ✔ runtime: 0 ms ✔ answer: 6 ✔ stdout: '' [Submission] ✔ Accepted ✔ 202/202 cases passed (1 ms) ✔ Your runtime beats 82.12 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/easy/344/":{"url":"leetcode/easy/344/","title":"344. Reverse String 反转字符串","keywords":"","body":"[344] Reverse String 反转字符串 [Page Address] * https://leetcode.com/problems/reverse-string/description/ * * algorithms * Easy (63.72%) * Total Accepted: 477.9K * Total Submissions: 748.4K [Problem Description] * Write a function that reverses a string. The input string is given as an * array of characters char[]. * * Do not allocate extra space for another array, you must do this by modifying * the input array in-place with O(1) extra memory. * * You may assume all the characters consist of printable ascii * characters. * * * * * Example 1: * * * Input: [\"h\",\"e\",\"l\",\"l\",\"o\"] * Output: [\"o\",\"l\",\"l\",\"e\",\"h\"] * * * * Example 2: * * * Input: [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] * Output: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 示例 1： 输入：[\"h\",\"e\",\"l\",\"l\",\"o\"] 输出：[\"o\",\"l\",\"l\",\"e\",\"h\"] 示例 2： 输入：[\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"] 输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"] [Difficulty: EASY] [Design] 从左右两边界开始，左指针所对应字符和右指针所对应字符互相交换，直到左右两指针重叠或交叉； [Note] 1. swap函数可以帮助交换值； 2. java函数中对于数组array的传递为引用传递； [CodeWar] class Solution { public void reverseString(char[] s) { int leftIndex = 0; int rightIndex = s.length - 1; while (leftIndex [Testing] Input data: [\"h\",\"e\",\"l\",\"l\",\"o\"] Actual ✔ runtime: 0 ms ✔ answer: [\"o\",\"l\",\"l\",\"e\",\"h\"] ✔ stdout: '' Expected ✔ runtime: 4 ms ✔ answer: [\"o\",\"l\",\"l\",\"e\",\"h\"] ✔ stdout: '' [Submission] ✔ Accepted ✔ 478/478 cases passed (1 ms) ✔ Your runtime beats 94.59 % of java submissions Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/medium/":{"url":"leetcode/medium/","title":"Difficulty: MEDIUM","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/medium/2.html":{"url":"leetcode/medium/2.html","title":"2. Add Two Numbers","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/hard/":{"url":"leetcode/hard/","title":"Difficulty: HARD","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"leetcode/hard/4.html":{"url":"leetcode/hard/4.html","title":"4. Median of Two Sorted Arrays","keywords":"","body":"TODO: Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/":{"url":"collections/","title":"Collections","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/":{"url":"collections/huawei/","title":"华为","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/0/":{"url":"collections/huawei/0/","title":"0. 剔除字符串中重复字符","keywords":"","body":"Remove Repeat Chars in String [Source: HUA WEI] [Problem Description] 给出一个字符串，将重复的字符去除，仅保留第一次出现的字符，且保持去重后的字符在原字符串中的顺序不变。 [Difficulty: EASY] [Problem Requirnment] 输入数据是一个字符串（不包含空格） 输出去重后的字符串 输入：12ere2 输出：12er [Design] 1. 将字符串转为字符列表； 2. 用HashMap存下每个字符第一次出现的Index； 3. 遍历整个字符串列表，仅保留符合HashMap记录数据的字符； [CodeWar] import java.io.*; import java.util.*; public class removeRepeats { public static String removeRepeat (String input) { char[] inputArray = input.toCharArray(); Map map = new HashMap(); int counter = 0; for (int i = 0; i [Testing] public static void main(String[] args) { String test_1 = \"abacbd\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_1)); System.out.println(\"should be: abcd\"); String test_2 = \"abc\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_2)); System.out.println(\"should be: abc\"); String test_3 = \"aaa\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_3)); System.out.println(\"should be: a\"); String test_4 = \"aabbccdd\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_4)); System.out.println(\"should be: abcd\"); String test_5 = \"12ere2\"; System.out.print(\"output is: \"); System.out.println(removeRepeat(test_5)); System.out.println(\"should be: 12er\"); /* output is: abcd should be: abcd output is: abc should be: abc output is: a should be: a output is: abcd should be: abcd output is: 12er should be: 12er */ } Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/1/":{"url":"collections/huawei/1/","title":"1. 字符串最后一个单词的长度","keywords":"","body":"Count the length of last word [Source: HUA WEI] [Problem Description] 计算字符串最后一个单词的长度，单词以空格隔开。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 一行字符串，非空，长度小于5000。 输出描述: 整数N，最后一个单词的长度。 [Design] 1. 运用split方法将包含多单词的字符串分割为String Array； 2. 直接获取最后一位的字符串长度； [Note] str.split()方法: str = \"hello world\"; str.split -> return type: String[] {hello, world} [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String[] inputArray = scanner.nextLine().split(\" \"); System.out.println(inputArray[inputArray.length-1].length()); } } } [Testing] 输入 hello world 输出 5 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/2/":{"url":"collections/huawei/2/","title":"2. 计算目标字符个数","keywords":"","body":"计算目标字符个数 [Source: HUA WEI] [Problem Description] 写出一个程序，接受一个由字母和数字组成的字符串，和一个字符，然后输出输入字符串中含有该字符的个数。不区分大小写。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 第一行输入一个有字母和数字以及空格组成的字符串，第二行输入一个字符。 输出描述: 输出输入字符串中含有该字符的个数。 [Design] 1. 由于本题不区分字母大小写，在把整个字符串直接转化为统一小写字母的charArray； 2. 将目标字符也按照统一标准转化为小写字母； 3. 遍历整个charArray进行比较并计数； [Note] 1. Character.toLowerCase(String str) -> 会将字符串中所有大写字母转小写，其余不变, 返回新字符串； 2. Character.toLowerCase(char c) -> 如果该字符是大写字母，将会被转为小写字母，否则保持不变，返回新字符； 3. str.toCharArray() -> 将str按照每个字符，按顺序分割为charArray，返回新charArray; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner input = new Scanner(System.in); char[] inputArray; char target; int counter = 0; while (input.hasNext()) { inputArray = input.nextLine().toLowerCase().toCharArray(); target = Character.toLowerCase(input.next().charAt(0)); for (char c:inputArray) { if (target == c) { counter++; } } System.out.println(counter); counter = 0; } } } [Testing] 输入 ABCDEF A 输出 1 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/3/":{"url":"collections/huawei/3/","title":"3. 随机数去重和排序","keywords":"","body":"随机数去重和排序 [Source: HUA WEI] [Problem Description] 明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据，希望大家能正确处理)。 Input Param n 输入随机数的个数 inputArray n个随机整数组成的数组 Return Value OutputArray 输出处理后的随机整数 注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入多行，先输入随机整数的个数，再输入相应个数的整数 输出描述: 返回多行，处理后的结果 [Design] 1. 获取总随机数个数，得到循坏次数； 2. 用HashSet存储所有随机数并完成去重工作； 3. 将hashSet转换为array，然后对array进行排序； [Note] 1. 建立一个HashSet: Set hashSet = new HashSet(); 2. 将hashSet转换为array: hashSet.toArray() -> 将hashSet变为对应类型array，返回新array； 3. 排序一个array Arrays.sort(Object[] array) -> 直接排序输入array，直接覆盖原array, 不返回值； 4. array转换为string Arrays.toString(Object[] array) -> 将array转换为string，返回新string； 5. char转换为string Character.toString(char c) -> 将char转换为string，返回新string； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner input = new Scanner(System.in); while(input.hasNext()) { int length = input.nextInt(); Set set = new HashSet(); for (int i = 0; i [Testing] 输入 11 10 20 40 32 67 40 20 89 300 400 15 输出 10 15 20 32 40 67 89 300 400 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/4/":{"url":"collections/huawei/4/","title":"4. 字符串分割","keywords":"","body":"字符串分割 [Source: HUA WEI] [Problem Description] •连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组； •长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 连续输入字符串(输入2次,每个字符串长度小于100) 输出描述: 输出到长度为8的新字符串数组 [Design] 1. 计算是否字符串可以被8整除，即判断最后一个被分割下来的字符串需不需要补'0'； 2. 如果需要补'0'，计算需要补的个数，然后直接添加到未分割的字符串末尾； 3. 以8为间隔分割字符串； [Note] 1. 分割字符串方法： str.substring(a) -> 截取从index a 到 末尾的整个字符串，包含a，返回新字符串； str.substring(a, b) -> 截取从index a 到 index b的整个字符串，包含a不包含b，返回新字符串； 2. scanner.nextInt() 不会跳转到下一行，记得手动用 scanner.nextLine()跳转； 3. scanner.next() 会自动跳转到下一行； 4. 读取下一个字符： scanner.next().charAt(0); 5. 补充：scanner.next() 和 scanner.nextLine()的区别： input stream = \"hello world\" // 用scanner.next()连续System.out.print需要打印两次 -> helloworld // 用scanner.nextLine()System.out.print只用打印一次 -> hello world 简单来说，基本运行效果相同，但是next不会读取后面的空格；next遇到空格会停止，但是nextLine会读取整行内容直到遇到换行符； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void printSubstrings(String str) { int leftNums = str.length()%8; int fixLoopTimes = 0; if (leftNums != 0) { fixLoopTimes = 8 - leftNums; } for (int i = 0; i [Testing] 输入 abc 123456789 输出 abc00000 12345678 90000000 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-11 18:08:26 "},"collections/huawei/5/":{"url":"collections/huawei/5/","title":"5. 进制转换","keywords":"","body":"进制转换 [Source: HUA WEI] [Problem Description] 写出一个程序，接受一个十六进制的数值字符串，输出该数值的十进制字符串。（多组同时输入 ） [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个十六进制的数值字符串。 输出描述: 输出该数值的十进制字符串。 [Design] 1. 利用str.substring拆离出有效计数位； 2. 使用Integer.parseInt()转换有效计数位； [Note] 关于利用java内置库将非十进制数字转化到十进制： 举例：转化 \"0xA\" -> 10 Integer.parseInt(\"A\", 16); -> 10 java official docs: https://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#parseInt(java.lang.String,%20int) [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { String input = scanner.nextLine().substring(2); int result = Integer.parseInt(input, 16); System.out.println(result); } } } [Testing] 输入 0xA 输出 10 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-11 18:08:26 "},"collections/huawei/6/":{"url":"collections/huawei/6/","title":"6. 质数因子","keywords":"","body":"质数因子 [Source: HUA WEI] [Problem Description] 功能:输入一个正整数，按照从小到大的顺序输出它的所有质数的因子（如180的质数因子为2 2 3 3 5 ） 最后一个数后面也要有空格 详细描述： 函数接口说明： public String getResult(long ulDataInput) 输入参数： long ulDataInput：输入的正整数 返回值： String [Difficulty: MEDIUM] [Problem Requirnment] 输入描述: 输入一个long型整数 输出描述: 按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。 [Design] 利用分解质因数规则： https://www.shuxuele.com/prime-factorization.html [Note] 如何将char转换为String: 1. String str = 'c' + \"\"; 2. String str = Character.toString('c'); [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printPrims(scanner.nextLong()); } } public static void printPrims(long num) { if (num == 0) { System.out.println(\"0 \"); return; } String res = \"\"; int curPrim = 2; while (num != 1) { while (num % curPrim == 0) { res = res + curPrim + \" \"; num = num / curPrim; } curPrim++; } System.out.println(res); } } [Testing] 输入 180 输出 2 2 3 3 5 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-08-11 18:08:26 "},"collections/huawei/7/":{"url":"collections/huawei/7/","title":"7. 取近似值","keywords":"","body":"取近似值 [Source: HUA WEI] [Problem Description] 写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个正浮点数值 输出描述: 输出该数值的近似整数值 [Design] 1. 将double类型输入转化为字符串； 2. 分离出最后一位； 3. 分离出整数部分； 4. 如果最后一位小数大于等于5，整数部分在原值基础加一； 5. 返回新整数部分； [Note] 本题没有考虑小数点后超过一位的情况，仅适用于小数点后仅有一位的情况； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printFloatAsInt(scanner.nextFloat()); } } public static void printFloatAsInt(float num) { String numStr = Float.toString(num); String floatPartStr = numStr.substring(numStr.length()-1); Integer numPart = Integer.parseInt(numStr.substring(0, numStr.length()-2)); if (Integer.parseInt(floatPartStr) >= 5) { numPart++; } System.out.println(numPart); } } [Testing] 输入 5.5 输出 6 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/8/":{"url":"collections/huawei/8/","title":"8. 合并表数据","keywords":"","body":"合并表记录 [Source: HUA WEI] [Problem Description] 数据表记录包含表索引和数值，请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 先输入键值对的个数 然后输入成对的index和value值，以空格隔开 输出描述: 输出合并后的键值对（多行） [Design] 1. 用ArrayList记录下每一次不重复的新的key值； 2. 用HashMap记录和更新key值对应value的和； 3. 将ArrayList用Collections.sort()排序； 4. 按顺序从小到大，升序打印出对应的HashMap中key所对应的value; [Note] None [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int loopTimes = scanner.nextInt(); ArrayList keysArrayList = new ArrayList(); Map map = new HashMap(); for (int i = 0; i [Testing] 输入 4 0 1 0 2 1 2 3 4 输出 0 3 1 2 3 4 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/9/":{"url":"collections/huawei/9/","title":"9. 提取不重复的整数","keywords":"","body":"提取不重复的整数 [Source: HUA WEI] [Problem Description] 输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个int型整数 输出描述: 按照从右向左的阅读顺序，返回一个不含重复数字的新的整数 [Design] 1. ArrayList按照顺序记录下所有出现过的不重复的字符； 2. HashMap记录和更新，以字符为key，出现次数为value； 3. 按照顺序，在HashMap中查询ArrayList对应的key的value；仅打印出现次数为1的key； [Note] None； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printNoRepeatInt(scanner.nextInt()); } } public static void printNoRepeatInt(int num) { String numStr = Integer.toString(num); Map map = new HashMap(); ArrayList resArrayList = new ArrayList(); for (int i = numStr.length() - 1; i >= 0; i--) { if (!map.containsKey(numStr.charAt(i))) { map.put(numStr.charAt(i), 1); resArrayList.add(numStr.charAt(i)); } } String resStr = \"\"; for (int i = 0; i [Testing] 输入 9876673 输出 37689 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/10/":{"url":"collections/huawei/10/","title":"10. 字符个数统计","keywords":"","body":"字符个数统计 [Source: HUA WEI] [Problem Description] 编写一个函数，计算字符串中含有的不同字符的个数。 字符在ACSII码范围内(0~127)。不在范围内的不作统计。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入N个字符，字符在ACSII码范围内。 输出描述: 输出范围在(0~127)字符的个数。 [Design] 1. 用HashMap判断当前字符是否出现过，和记录新字符； 2. 如果没出现过，且满足ascii范围，则加入HashMap，并给counter + 1； 3. 返回counter; [Note] 1. 如何拿到char对应的ASCII码： char c = 'a'; int cAscii = c; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printNumInRangeOfAcsii(scanner.nextLine()); } } public static void printNumInRangeOfAcsii(String str) { char[] charArray = str.toCharArray(); int counter = 0; Map map = new HashMap(); for (char c:charArray) { int acsiiIndex = c; if (acsiiIndex > 0 && acsiiIndex [Testing] 输入 abc 输出 3 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/11/":{"url":"collections/huawei/11/","title":"11. 数字颠倒","keywords":"","body":"数字颠倒 [Source: HUA WEI] [Problem Description] 输入一个整数，将这个整数以字符串的形式逆序输出 程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个int整数 输出描述: 将这个整数以字符串的形式逆序输出 [Design] 1. 将输入的整数以字符串形式获取； 2. 倒序遍历打印； [Note] 倒序遍历注意i遍历范围； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printReversly(scanner.nextLine()); } } // print a string reversly public static void printReversly(String str) { String res = \"\"; for (int i = str.length()-1; i >= 0; i--) { res += str.charAt(i); } System.out.println(res); } } [Testing] 示例1 输入 1516000 输出 0006151 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/12/":{"url":"collections/huawei/12/","title":"12. 句子逆序","keywords":"","body":"句子逆序 [Source: HUA WEI] [Problem Description] 将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I” 所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符 接口说明 /** * 反转句子 * * @param sentence 原句子 * @return 反转后的句子 */ public String reverse(String sentence); [Difficulty: EASY] [Problem Requirnment] 输入描述: 将一个英文语句以单词为单位逆序排放。 输出描述: 得到逆序的句子 [Design] 1. 将输入的整数以字符串形式获取； 2. 分割字符串 2. 倒序遍历打印； [Note] 倒序遍历注意i遍历范围； [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printScentenceReversly(scanner.nextLine()); } } public static void printScentenceReversly(String str) { String[] wordsArray = str.split(\" \"); for (int i = wordsArray.length-1; i >= 0; i-- ) { System.out.print(wordsArray[i] + \" \"); } System.out.println(); } } [Testing] 输入 I am a boy 输出 boy a am I Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/13/":{"url":"collections/huawei/13/","title":"13. 字串的连接最长路径查找","keywords":"","body":"字串的连接最长路径查找 [Source: HUA WEI] [Problem Description] 给定n个字符串，请对n个字符串按照字典序排列。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。 输出描述: 数据输出n行，输出结果为按照字典序排列的字符串。 [Design] 直接利用Arryas.sort()方法排列； [Note] None； [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int loopTimes = scanner.nextInt(); scanner.nextLine(); String[] strArray = new String[loopTimes]; for (int i = 0; i [Testing] 输入 9 cap to cat card two too up boat boot 输出 boat boot cap card cat to too two up Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/14/":{"url":"collections/huawei/14/","title":"14. 求int型数据在内存中存储时1的个数","keywords":"","body":"求int型数据在内存中存储时1的个数 [Source: HUA WEI] [Problem Description] 输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入一个整数（int类型） 输出描述: 这个数转换成2进制后，输出1的个数 [Design] 1. 将整数输入利用Integer.toBinaryString(Type : int) 方法转变为binary string； 2. 查询1的个数； [Note] Integer.toBinaryString(Type : int) 方法可以把int 变为 binary string; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printAsBinary(scanner.nextInt()); } } public static void printAsBinary(int num) { String binaryStr = Integer.toBinaryString(num); int counter = 0; for (int i = 0; i [Testing] 输入 5 输出 2 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/15/":{"url":"collections/huawei/15/","title":"15. 坐标移动","keywords":"","body":"坐标移动 [Source: HUA WEI] [Problem Description] 开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。 输入： 合法坐标为A(或者D或者W或者S) + 数字（两位以内） 坐标之间以;分隔。 非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。 下面是一个简单的例子 如： A10;S20;W10;D30;X;A1A;B10A11;;A10; 处理过程： 起点（0,0） + A10 = （-10,0） + S20 = (-10,-20) + W10 = (-10,-10) + D30 = (20,-10) + x = 无效 + A1A = 无效 + B10A11 = 无效 + 一个空 不影响 + A10 = (10,-10) 结果 （10， -10） [Difficulty: MEDIUM] [Problem Requirnment] 输入描述: 一行字符串 输出描述: 最终坐标，以,分隔 [Design] 1. 首先获取所有输入，以’；‘分割为一个array； 2. 依次判断是否是合法输入 （仅有以下两种可能性为合法输入，因为数字限定为两位以内） a. 长度为2位 b. 长度为3位 3. 重新遍历，如果为合法操作，按照第一位的字符进行处理计算； [Note] 1. Type : String .substring(Type : int) 方法： String blogName = \"howtodoinjava.com\"; System.out.println(blogName.substring(3)); //todoinjava.com System.out.println(\"hello world\".substring(6)); //world [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { getLastPosition(scanner.nextLine()); } } public static void getLastPosition(String input) { String[] strArray = input.split(\";\"); int[] curPos = {0, 0}; int operationNum = 0; String curOperation = \"\"; for (int i = 0; i [Testing] 输入 A10;S20;W10;D30;X;A1A;B10A11;;A10; 输出 10,-10 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/16/":{"url":"collections/huawei/16/","title":"16. 密码验证合格程序","keywords":"","body":"密码验证合格程序 [Source: HUA WEI] [Problem Description] 密码要求: 1.长度超过8位 2.包括大小写字母.数字.其它符号,以上四种至少三种 3.不能有相同长度超2的子串重复 说明:长度超过2的子串 [Difficulty: EASY] [Problem Requirnment] 输入描述: 一组或多组长度超过2的子符串。每组占一行 输出描述: 如果符合要求输出：OK，否则输出NG [Design] 获取输入后，按条件依次判断即可；必需满足所有要求； 灵活运用hashmap去判断查找； [Note] None; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) { if (isLegalPassword(scanner.nextLine())) { System.out.println(\"OK\"); } else { System.out.println(\"NG\"); } } } public static boolean isLegalPassword(String str) { // check length; if (str.length() requireMap = new HashMap(); for (int i = 0; i repeatMap = new HashMap(); for (int i = 0; i [Testing] 输入 021Abc9000 021Abc9Abc1 021ABC9000 021$bc9000 输出 OK NG NG OK Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/17/":{"url":"collections/huawei/17/","title":"17. 简单密码","keywords":"","body":"简单密码 [Source: HUA WEI] [Problem Description] 密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。 假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。 他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换， 声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾 输出描述: 输出渊子真正的密文 [Design] 这题有一个讨巧的方法，每个字符对应的加密后符号都是固定的，所以做一个HashTable去链接对应关系即可； [Note] None; [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { System.out.println(decodePassword(scanner.nextLine())); } } public static String decodePassword (String str) { Map lowerCaseMap = new HashMap(); char[] charArray = str.toCharArray(); lowerCaseMap.put('a', '2'); lowerCaseMap.put('b', '2'); lowerCaseMap.put('c', '2'); lowerCaseMap.put('d', '3'); lowerCaseMap.put('e', '3'); lowerCaseMap.put('f', '3'); lowerCaseMap.put('g', '4'); lowerCaseMap.put('h', '4'); lowerCaseMap.put('i', '4'); lowerCaseMap.put('j', '5'); lowerCaseMap.put('k', '5'); lowerCaseMap.put('l', '5'); lowerCaseMap.put('m', '6'); lowerCaseMap.put('n', '6'); lowerCaseMap.put('o', '6'); lowerCaseMap.put('p', '7'); lowerCaseMap.put('q', '7'); lowerCaseMap.put('r', '7'); lowerCaseMap.put('s', '7'); lowerCaseMap.put('t', '8'); lowerCaseMap.put('u', '8'); lowerCaseMap.put('v', '8'); lowerCaseMap.put('w', '9'); lowerCaseMap.put('x', '9'); lowerCaseMap.put('y', '9'); lowerCaseMap.put('z', '9'); for (int i = 0; i [Testing] 输入 YUANzhi1987 输出 zvbo9441987 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/18/":{"url":"collections/huawei/18/","title":"18. 汽水瓶","keywords":"","body":"汽水瓶 [Source: HUA WEI] [Problem Description] 有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？ [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1[Design] 三种情况： 1. 当前手里没有汽水瓶了，直接返回； 2. 当手里大于2个汽水瓶，计算可以换多少瓶，换后手里还剩下几个瓶子；（一个空瓶子是不能换的，所以只考虑情况3，不考虑剩下1一个汽水瓶）； 3. 当前手里有2个汽水瓶，可以借一瓶； [Note] None； [CodeWar] import java.util.*; import java.io.*; public class Main{ public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { numbersCouldDrink(scanner.nextInt()); } } public static void numbersCouldDrink(int num) { int curBottleNum = num; int totalNum = 0; if (curBottleNum == 0) { return; } while (curBottleNum > 2) { totalNum += curBottleNum / 3; curBottleNum = curBottleNum / 3 + curBottleNum % 3; } if (curBottleNum == 2) { totalNum++; } System.out.println(totalNum); } } [Testing] 输入 3 10 81 0 输出 1 5 40 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/19/":{"url":"collections/huawei/19/","title":"19. 删除字符串中出现次数最少的字符","keywords":"","body":"删除字符串中出现次数最少的字符 [Source: HUA WEI] [Problem Description] 实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。 输出描述: 删除字符串中出现次数最少的字符后的字符串。 [Design] 记录下所有字符出现次数； 查找到最小的出现次数； 删除所有符合最小出现次数的字符； [Note] String s1=\"javatpoint is a very good website\"; String replaceString=s1.replace('a','e');//replaces all occurrences of 'a' to 'e' -> \"jevetpoint is e very good website\" [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { getNewStr(scanner.nextLine()); } } public static void getNewStr(String input) { HashMap map = new HashMap<>(); ArrayList list = new ArrayList<>(); for (char c : input.toCharArray()) { if (!map.containsKey(c)) { map.put(c, 1); list.add(c); continue; } map.put(c, map.get(c)+1); } int minOccur = Integer.MAX_VALUE; for (char c : list) { if (map.get(c) removeList = new ArrayList<>(); for (char c : list) { if (map.get(c) == minOccur) { input = input.replace(c+\"\", \"\"); } } //System.out.println(minOccur); //System.out.println(removeList.toString()); System.out.println(input); } } [Testing] 输入 abcdd 输出 dd Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/21/":{"url":"collections/huawei/21/","title":"21. 购物单","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/22/":{"url":"collections/huawei/22/","title":"22. 识别有效的IP地址和掩码并进行分类统计","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/23/":{"url":"collections/huawei/23/","title":"23. 简单错误记录","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/24/":{"url":"collections/huawei/24/","title":"24. 合唱队","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/25/":{"url":"collections/huawei/25/","title":"25. 数据分类处理","keywords":"","body":"数据分类处理 [Source: HUA WEI] [Problem Description] 信息社会，有海量的数据需要分析处理，比如公安局分析身份证号码、 QQ 用户、手机号码、银行帐号等信息及活动记录。 采集输入大数据和分类规则，通过大数据分类处理程序，将大数据分类输出。 [Difficulty: MEDIUM] [Problem Requirnment] 输入描述: ﻿一组输入整数序列I和一组规则整数序列R，I和R序列的第一个整数为序列的个数（个数不包含第一个整数）；整数范围为0~0xFFFFFFFF，序列个数不限 输出描述: ﻿从R依次中取出R，对I进行处理，找到满足条件的I： I整数对应的数字需要连续包含R对应的数字。比如R为23，I为231，那么I包含了R，条件满足 。 按R从小到大的顺序: (1)先输出R； (2)再输出满足条件的I的个数； (3)然后输出满足条件的I在I序列中的位置索引(从0开始)； (4)最后再输出I。 附加条件： (1)R需要从小到大排序。相同的R只需要输出索引小的以及满足条件的I，索引大的需要过滤掉 (2)如果没有满足条件的I，对应的R不用输出 (3)最后需要在输出序列的第一个整数位置记录后续整数序列的个数(不包含“个数”本身) 序列I：15,123,456,786,453,46,7,5,3,665,453456,745,456,786,453,123（第一个15表明后续有15个整数） 序列R：5,6,3,6,3,0（第一个5表明后续有5个整数） 输出：30, 3,6,0,123,3,453,7,3,9,453456,13,453,14,123,6,7,1,456,2,786,4,46,8,665,9,453456,11,456,12,786 说明： 30----后续有30个整数 3----从小到大排序，第一个R为0，但没有满足条件的I，不输出0，而下一个R是3 6--- 存在6个包含3的I 0--- 123所在的原序号为0 123--- 123包含3，满足条件 [Design] 1. 分别获取输入 2. 统一数据类型 3. 过滤重复r数据 4. 利用String.indexOf方法去查询和计数 5. 利用StringBuffer来记录所有符合的结果 [Note] 利用 (Type : String).indexOf(Type : String) 去查询是否包含目标子字符串； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main (String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { // get I Array int iNums = scanner.nextInt(); String[] iArray = new String[iNums]; for (int i = 0; i map = new HashMap<>(); // loop rArray for (int i = 0; i = 0) { counter++; } } // there are one or more match if (counter > 0) { sBuffer.append(curR + \" \" + counter + \" \"); for (int j = 0; j = 0) { sBuffer.append(j + \" \" + curI + \" \"); } } } } int length = sBuffer.toString().split(\" \").length; sBuffer.insert(0, length + \" \"); System.out.println(sBuffer); } } [Testing] 输入 15 123 456 786 453 46 7 5 3 665 453456 745 456 786 453 123 5 6 3 6 3 0 输出 30 3 6 0 123 3 453 7 3 9 453456 13 453 14 123 6 7 1 456 2 786 4 46 8 665 9 453456 11 456 12 786 Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/26/":{"url":"collections/huawei/26/","title":"26. 字符串排序","keywords":"","body":"字符串排序 [Source: HUA WEI] [Problem Description] 编写一个程序，将输入字符串中的字符按如下规则排序。 规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。 如，输入： Type 输出： epTy 规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。 如，输入： BabA 输出： aABb 规则 3 ：非英文字母的其它字符保持原来的位置。 如，输入： By?e 输出： Be?y [Difficulty: EASY] [Problem Requirnment] 样例： 输入： A Famous Saying: Much Ado About Nothing(2012/8). 输出： A aaAAbc dFgghh : iimM nNn oooos Sttuuuy (2012/8). [Design] 1. 获取输入； 2. 新建StringBuffer，利用ASCII码识别字母，并按照原本顺序加入所有字母字符； 3. 利用ASCII码筛出所有非字母字符，并利用StringBuffer特性将其插入原本index； [Note] 利用ASCII码辨别非字母字符； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { printSortStr(scanner.nextLine()); } scanner.close(); } public static void printSortStr(String str) { StringBuffer sBuffer = new StringBuffer(); // 利用ascii码来遍历aA-zZ; for (int i = 0; i = 'a' && curChar = 'A' && curChar [Testing] 输入 A Famous Saying: Much Ado About Nothing (2012/8). 输出 A aaAAbc dFgghh: iimM nNn oooos Sttuuuy (2012/8). Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/27/":{"url":"collections/huawei/27/","title":"27. 查找兄弟单词","keywords":"","body":"查找兄弟单词 [Source: HUA WEI] [Problem Description] https://www.nowcoder.com/practice/03ba8aeeef73400ca7a37a5f3370fe68?tpId=37&tqId=21250&tPage=2&rp=&ru=/ta/huawei&qru=/ta/huawei/question-ranking [Difficulty: EASY] [Problem Requirnment] 输入描述: 先输入字典中单词的个数n，再输入n个单词作为字典单词。 再输入一个单词，查找其在字典中兄弟单词的个数m 再输入数字k 输出描述: 根据输入，输出查找到的兄弟单词的个数m 然后输出查找到的兄弟单词的第k个单词。 [Design] 主要难点在于如何判断兄弟单词； 1. 不可以是完全相同单词； 2. 兄弟单词与原单词长度必定相等 3. 兄弟单词在重新字典序排序后，和原单词在重新字典序排序后，必定完全相同； [Note] Type : String .equals(Type : String) -> boolean 判断字符串内容是否相同，不可使用“==”，必需使用以上方程； [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()) { int wordsNum = scanner.nextInt(); String[] dict = new String[wordsNum]; for (int i = 0; i list = new ArrayList<>(); Arrays.sort(dict); for (String cur : dict) { if (isBrother(target, cur)) { list.add(cur); } } System.out.println(list.size()); if (brotherIndex 0) { System.out.println(list.get(brotherIndex - 1)); } } public static boolean isBrother(String target, String cur) { // target can not same as cur if (target.equals(cur)) { return false; } // length must be same if (target.length() != cur.length()) { return false; } // norm case char[] targetArray = target.toCharArray(); char[] curArray = cur.toCharArray(); // sortted array must be same Arrays.sort(targetArray); Arrays.sort(curArray); for (int i = 0; i [Testing] 输入 3 abc bca cab abc 1 输出 2 bca Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/28/":{"url":"collections/huawei/28/","title":"28. 素数伴侣","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/29/":{"url":"collections/huawei/29/","title":"29. 字符串加解密","keywords":"","body":"字符串加解密 [Source: HUA WEI] [Problem Description] 1、对输入的字符串进行加解密，并输出。 2加密方法为： 当内容是英文字母时则用该英文字母的后一个字母替换，同时字母变换大小写,如字母a时则替换为B；字母Z时则替换为a； 当内容是数字时则把该数字加1，如0替换1，1替换2，9替换0； 其他字符不做变化。 3、解密方法为加密的逆过程。 接口描述： 实现接口，每个接口实现1个基本操作： void Encrypt (char aucPassword[], char aucResult[])：在该函数中实现字符串加密并输出 说明： 1、字符串以\\0结尾。 2、字符串最长100个字符。 int unEncrypt (char result[], char password[])：在该函数中实现字符串解密并输出 说明： 1、字符串以\\0结尾。 2、字符串最长100个字符。 [Difficulty: EASY] [Problem Requirnment] 输入描述: 输入说明 输入一串要加密的密码 输入一串加过密的密码 输出描述: 输出说明 输出加密后的字符 输出解密后的字符 [Design] 加密解密每个字符对应的字符是固定的，所以可以直接列出，更便利； [Note] None; [CodeWar] import java.util.*; import java.io.*; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); while (scanner.hasNext()){ String decrypted = scanner.nextLine(); String encrypted = scanner.nextLine(); encrypte(decrypted); decrypte(encrypted); } } public static void encrypte (String input) { String str1=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; String str2=\"bcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZA1234567890\"; StringBuffer sBuffer = new StringBuffer(); for (char c : input.toCharArray()) { if (str1.indexOf(c) >= 0) { sBuffer.append(str2.charAt(str1.indexOf(c))); continue; } sBuffer.append(c); } System.out.println(sBuffer); } public static void decrypte (String input) { String str1=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"; String str2=\"bcdefghijklmnopqrstuvwxyzaBCDEFGHIJKLMNOPQRSTUVWXYZA1234567890\"; StringBuffer sBuffer = new StringBuffer(); for (char c : input.toCharArray()) { if (str2.indexOf(c) >= 0) { sBuffer.append(str1.charAt(str2.indexOf(c))); continue; } sBuffer.append(c); } System.out.println(sBuffer); } } [Testing] 输入 abcdefg BCDEFGH 输出 BCDEFGH abcdefg Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/30/":{"url":"collections/huawei/30/","title":"30. 字符串合并处理","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/31/":{"url":"collections/huawei/31/","title":"31. 【中级】单词倒排","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/32/":{"url":"collections/huawei/32/","title":"32. 【中级】字符串运用-密码截取","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"collections/huawei/33/":{"url":"collections/huawei/33/","title":"33. 整数与IP地址间的转换","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/":{"url":"knowledge/","title":"Basic Knowledge","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/dataStructures/":{"url":"knowledge/dataStructures/","title":"Data Structures","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/algorithems/":{"url":"knowledge/algorithems/","title":"Algorithems","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/":{"url":"knowledge/languages/","title":"Languages","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/java/":{"url":"knowledge/languages/java/","title":"Java","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/python/":{"url":"knowledge/languages/python/","title":"Python","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/javaScript/":{"url":"knowledge/languages/javaScript/","title":"JavaScript","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/c/":{"url":"knowledge/languages/c/","title":"C","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/cpp/":{"url":"knowledge/languages/cpp/","title":"C++","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/swift/":{"url":"knowledge/languages/swift/","title":"Swift","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/languages/html5_css3/":{"url":"knowledge/languages/html5_css3/","title":"HTML5 && CSS3","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/tools/":{"url":"knowledge/tools/","title":"Tools","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/tools/git/":{"url":"knowledge/tools/git/","title":"Git","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/tools/docker/":{"url":"knowledge/tools/docker/","title":"Docker","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/tools/mySql/":{"url":"knowledge/tools/mySql/","title":"MySQL","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/gameDevelopment/":{"url":"knowledge/gameDevelopment/","title":"Game Development","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/gameDevelopment/unity3D/":{"url":"knowledge/gameDevelopment/unity3D/","title":"Unity3D","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "},"knowledge/gameDevelopment/unreal4/":{"url":"knowledge/gameDevelopment/unreal4/","title":"Unreal 4","keywords":"","body":"TODO Copyright © sparklscn.com 2019 all right reserved，powered by GitbookLast update： 2019-10-22 12:37:08 "}}