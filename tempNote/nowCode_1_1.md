时间复杂度：
	bigO是指算法的上限（worst case）
	评价一个算法流程的好坏，先看时间复杂度的指标，然后再分析不同数据样本下的实际运行时间，也就是“常数项时间”

选择排序	时间: O(N^2)	空间: O(1)
冒泡排序	时间: O(N^2)	空间: O(1)
插入排序	时间: O(N^2)	空间: O(1)


位运算: 
	异或运算 就是无进位相加
		0 ^ n = n
		n ^ n = 0;
		一批量异或运算 符合交换律和结合律 
			用无进位相加思路来证明：
swap： // 必需保证 a 和 b 内存位置不一样，比如a=b=array[10]
	a = a ^ b
	b = a ^ b
	a = a ^ b

	int a = A; int b = B;
	a = a ^ b    ->    a = A ^ B    b = B;
	b = a ^ b 	 ->    a = A ^ B    b = A ^ B ^ B => A ^ 0 => A;
	a = a ^ b    ->    a = A ^ B ^ A => 0 ^ B => B

额外空间复杂度：
	输入和返回都不算额外空间；

一个array 有一个数出现奇数次，别的都是偶数次数 O(n) O(1)
	int eor = 0;
	eor ^ array[]

一个array 有两个数出现奇数次，别的都是偶数次数 O(n) O(1)
	int eor = 0;
	eor ^ array[]
	// eor 是 a ^ b
	// 因为 a != b， 所以 a ^ b 在某一个二进制位（x）一定是1，选最右侧的1;
	int eor' = 0;
	eor' ^ array[] 仅在x位为1时候进行操作；
	// 此时  eor' 即为 a 或者 b， 因为a 和 b 只有一个在x位为1;同时别的数不管符合不符合x位为1，都是偶数次出现，最后都会被忽略不计；
	// 假如 eor' 为 a
	a = eor'
	b = eor ^ eor'

二分法：
	二分法可以构建 1.数据状况 2.问题要求

对数器：

随机：
	Random函数，在数学上是做不到的。但是计算机可以，因为计算机所表示的小数是有穷尽的，所以可以做到等概率取出一个随机数；
	Math.random() -> [0, 1) 所有小数
	Math.random() * N -> [0, N)	所有小数
	(int)(Math.random() * N) -> [0, N-1] 所有整数

递归：
	递归不是玄学，它后台落地的所有东西都是十分坚实的；
	时间复杂度：
	```
		master公式的使用 T(N) = a*T(N/b) + O(N^d)
		1) log(b,a) > d -> 复杂度为O(N^log(b,a))
		2) log(b,a) = d -> 复杂度为O(N^d * logN)
		3) log(b,a) < d -> 复杂度为O(N^d)
	```

附加：
	关于求中间值：
		mid = (L+R)/2 //L+R有可能溢出
		-> L + (R-L)/2
		-> L + (R-L)>>1 //右移一位代表除以二
		// >> 意义为带符号位移（按照高位填左边） >>> 高位一律用0来填
		// << 和 <<< 没有区别
